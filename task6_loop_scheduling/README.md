# Task 6: OpenMP Loop Scheduling Investigation

## Описание задачи (Task Description)

Проведение исследования режимов распараллеливания цикла for (static, dynamic, guided): создание цикла с неравномерной нагрузкой итераций (на некоторых итерациях генерируются случайные числа) и анализ изменения времени работы программы при различных режимах работы цикла for.

**Investigation of OpenMP loop scheduling modes (static, dynamic, guided):** Creating a loop with uneven iteration workload (some iterations generate random numbers) and analyzing how execution time changes with different loop scheduling strategies.

## Структура проекта (Project Structure)

```
task6_loop_scheduling/
├── src/                          # Source code
│   └── loop_scheduling.cpp       # Main program with uneven workload
├── scripts/                      # Automation scripts
│   ├── compile.sh                # Compilation script
│   ├── run_benchmarks.sh         # Benchmark runner
│   └── test_pipeline.sh          # Full test pipeline
├── data/                         # Configuration files
│   └── test_configs.json         # Test parameters
├── analysis/                     # Analysis scripts
│   ├── analyze.py                # Results processing
│   └── plot_graphs.py            # Graph generation
├── bin/                          # Compiled binaries
├── results/                      # Benchmark results (CSV)
├── graphs/                       # Generated graphs
├── .gitignore                    # Git ignore file
└── README.md                     # This file
```

## Быстрый старт (Quick Start)

### 1. Компиляция (Compilation)

```bash
cd task6_loop_scheduling/scripts
chmod +x *.sh
./compile.sh
```

Скрипт автоматически:
- Определит вашу ОС (macOS/Linux)
- Найдет подходящий компилятор с поддержкой OpenMP
- Скомпилирует программу с оптимизациями
- Проверит работу OpenMP

### 2. Быстрый тест (Quick Test)

```bash
./test_pipeline.sh
```

Выполнит:
- Компиляцию программы
- Проверку корректности вычислений
- Быстрый бенчмарк
- Проверку зависимостей Python

### 3. Полный бенчмарк (Full Benchmark)

```bash
./run_benchmarks.sh
```

Запустит полный набор тестов:
- Количество итераций: 1000, 2000, 5000, 10000
- Количество потоков: 1, 2, 4, 8, 16, 32, 64, 128
- Стратегии планирования: static, dynamic, guided
- Размеры chunk: 0 (default), 1, 5, 10, 50
- По 10 запусков каждой конфигурации

⏱️ **Время выполнения:** ~30-60 минут в зависимости от системы

### 4. Анализ результатов (Analysis)

```bash
cd ../analysis

# Обработка данных
python3 analyze.py ../results/benchmark_YYYYMMDD_HHMMSS.csv

# Генерация графиков
python3 plot_graphs.py
```

## Использование программы (Program Usage)

### Формат команды

```bash
./bin/loop_scheduling <num_iterations> <num_threads> <schedule> <chunk_size> <runs> [output_file]
```

### Параметры

- `num_iterations` - количество итераций цикла (1000, 2000, 5000, 10000)
- `num_threads` - количество потоков OpenMP (1, 2, 4, 8, 16, 32, 64, 128)
- `schedule` - стратегия планирования:
  - `sequential` - последовательное выполнение (baseline)
  - `static` - статическое распределение
  - `dynamic` - динамическое распределение
  - `guided` - управляемое распределение
- `chunk_size` - размер chunk для планирования (0 = default)
- `runs` - количество запусков для усреднения
- `output_file` - (опционально) файл для сохранения результатов

### Примеры

```bash
# Последовательное выполнение (baseline)
./bin/loop_scheduling 5000 1 sequential 0 10

# Static scheduling, 4 потока
./bin/loop_scheduling 5000 4 static 0 10

# Dynamic scheduling, 8 потоков, chunk=10
./bin/loop_scheduling 5000 8 dynamic 10 10

# Guided scheduling, 16 потоков
./bin/loop_scheduling 10000 16 guided 0 5

# С сохранением в файл
./bin/loop_scheduling 5000 8 dynamic 10 10 results/test.csv
```

## Реализация (Implementation)

### Паттерн неравномерной нагрузки (Uneven Workload Pattern)

Программа создает цикл с сильно неравномерной нагрузкой:

```cpp
for (int i = 0; i < num_iterations; ++i) {
    if (i % 10 == 0) {
        // Очень тяжелая работа каждую 10-ю итерацию
        // Генерация и обработка 10000 случайных чисел
        sum += heavy_work(i, 10000);
    } else if (i % 5 == 0) {
        // Средняя работа каждую 5-ю итерацию (не 10-ю)
        // Генерация и обработка 5000 случайных чисел
        sum += heavy_work(i, 5000);
    } else {
        // Легкая работа для остальных итераций
        // Минимальные вычисления
        sum += light_work(i);
    }
}
```

**Распределение нагрузки:**
- 10% итераций: очень тяжелая работа (10000 операций)
- 10% итераций: средняя работа (5000 операций)
- 80% итераций: легкая работа (минимальные вычисления)

Это создает значительный дисбаланс нагрузки, который по-разному влияет на различные стратегии планирования.

### Стратегии планирования OpenMP (Scheduling Strategies)

#### 1. Static Schedule

```cpp
#pragma omp parallel for schedule(static, chunk_size) reduction(+:total_sum)
```

**Характеристики:**
- Итерации распределяются равномерно между потоками при запуске
- Каждый поток получает непрерывный блок итераций
- Минимальные накладные расходы на синхронизацию
- Предсказуемое распределение работы

**Преимущества:**
- Наименьшие накладные расходы
- Хорошая локальность данных
- Эффективно для равномерной нагрузки

**Недостатки:**
- Плохая балансировка при неравномерной нагрузке
- Некоторые потоки заканчивают рано, другие поздно
- Низкая эффективность для данной задачи

**Применение:**
- Равномерная нагрузка
- Предсказуемое время выполнения итераций

#### 2. Dynamic Schedule

```cpp
#pragma omp parallel for schedule(dynamic, chunk_size) reduction(+:total_sum)
```

**Характеристики:**
- Итерации распределяются динамически во время выполнения
- Потоки получают новые chunk'и по мере завершения предыдущих
- Автоматическая балансировка нагрузки
- Больше накладных расходов на синхронизацию

**Преимущества:**
- Отличная балансировка нагрузки
- Потоки не простаивают
- Эффективно для неравномерной нагрузки

**Недостатки:**
- Больше накладных расходов на синхронизацию
- Хуже локальность данных
- Производительность зависит от chunk_size

**Применение:**
- Неравномерная нагрузка (как в данной задаче)
- Непредсказуемое время выполнения итераций

#### 3. Guided Schedule

```cpp
#pragma omp parallel for schedule(guided, chunk_size) reduction(+:total_sum)
```

**Характеристики:**
- Размер chunk'а уменьшается экспоненциально
- Начинает с больших chunk'ов, заканчивает маленькими
- Компромисс между static и dynamic
- Адаптивное распределение работы

**Преимущества:**
- Хорошая балансировка нагрузки
- Меньше накладных расходов чем dynamic
- Адаптируется к паттерну нагрузки

**Недостатки:**
- Более сложная логика
- Может быть неоптимальна для некоторых паттернов

**Применение:**
- Постепенно меняющаяся нагрузка
- Когда нужен баланс между overhead и балансировкой

### Влияние chunk_size

- **chunk_size = 0 (default)**: OpenMP выбирает оптимальный размер
- **chunk_size = 1**: Наилучшая балансировка, максимальные накладные расходы
- **chunk_size = 5**: Малые chunk'и, хорошая балансировка, умеренные накладные расходы
- **chunk_size = 10**: Средние chunk'и, сбалансированный компромисс
- **chunk_size = 50**: Большие chunk'и, меньше накладных расходов, хуже балансировка

## Проверка корректности (Correctness Verification)

Программа автоматически проверяет корректность:

```
=== Correctness Verification ===
Sequential result: 123456.789012
Static result:     123456.789012 (error: 0.000000e+00)
  ✓ PASSED
Dynamic result:    123456.789012 (error: 0.000000e+00)
  ✓ PASSED
Guided result:     123456.789012 (error: 0.000000e+00)
  ✓ PASSED
```

✅ Все стратегии дают корректные и согласованные результаты!

## Метрики производительности (Performance Metrics)

### 1. Время выполнения (Execution Time)
Абсолютное время выполнения операции в миллисекундах.

### 2. Ускорение (Speedup)
```
Speedup = T(sequential) / T(parallel)
```
где T(sequential) - время последовательного выполнения, T(parallel) - время параллельного.

### 3. Эффективность (Efficiency)
```
Efficiency = Speedup / n
```
где n - количество потоков.

Идеальная эффективность = 1.0 (100%)

## Генерируемые графики (Generated Graphs)

После запуска анализа в директории `graphs/` создаются:

1. **execution_time_iter_*.png** - Время выполнения vs количество потоков
2. **speedup_iter_*.png** - Ускорение vs количество потоков (с идеальной линией)
3. **efficiency_iter_*.png** - Эффективность vs количество потоков
4. **schedule_comparison.png** - Сравнение всех стратегий
5. **chunk_size_impact_iter_*.png** - Влияние chunk_size на производительность
6. **summary_table.txt** - Сводная таблица результатов

## Требования (Requirements)

### Система (System)
- macOS или Linux
- Компилятор с поддержкой OpenMP:
  - GCC 11+ (рекомендуется для macOS)
  - Clang с libomp
  - GCC на Linux
- Минимум 4 ядра CPU (рекомендуется 8+)

### Python (для анализа)
```bash
pip3 install pandas matplotlib numpy
```

## Установка зависимостей (Dependencies Installation)

### macOS

```bash
# Установка GCC с OpenMP (рекомендуется)
brew install gcc

# Или установка libomp для Clang
brew install libomp

# Python пакеты
pip3 install pandas matplotlib numpy
```

### Linux

```bash
# GCC обычно уже установлен
sudo apt-get update
sudo apt-get install g++

# Python пакеты
pip3 install pandas matplotlib numpy
```

## Ожидаемые результаты (Expected Results)

### Static Schedule
- **Малое количество потоков (1-4)**: Приемлемая производительность
- **Среднее количество потоков (8-16)**: Заметный дисбаланс нагрузки
- **Большое количество потоков (32+)**: Плохая эффективность из-за дисбаланса

**Причина:** Тяжелые итерации могут попасть одному потоку, который будет работать долго, пока другие простаивают.

### Dynamic Schedule
- **Малое количество потоков (1-4)**: Хорошая производительность
- **Среднее количество потоков (8-16)**: Отличная балансировка
- **Большое количество потоков (32+)**: Хорошая производительность, но накладные расходы растут

**Причина:** Автоматическая балансировка нагрузки компенсирует неравномерность работы.

### Guided Schedule
- **Малое количество потоков (1-4)**: Хорошая производительность
- **Среднее количество потоков (8-16)**: Очень хорошая балансировка
- **Большое количество потоков (32+)**: Оптимальный компромисс

**Причина:** Адаптивный размер chunk'а обеспечивает баланс между overhead и балансировкой.

### Влияние chunk_size

**Для dynamic и guided:**
- **Малый chunk (1-5)**: Лучшая балансировка, но больше накладных расходов
- **Средний chunk (10)**: Хороший баланс
- **Большой chunk (50)**: Меньше накладных расходов, но хуже балансировка

## Для отчета (For Report)

Используйте следующие материалы:

1. **Графики ускорения** - показывают эффективность разных стратегий
2. **Графики эффективности** - демонстрируют качество масштабирования
3. **Сравнение стратегий** - влияние scheduling на производительность
4. **Влияние chunk_size** - как размер chunk влияет на балансировку
5. **Таблица summary_table.txt** - числовые данные для отчета

## Ключевые выводы (Key Findings)

1. ✅ **Стратегия планирования критична для неравномерной нагрузки**
   - Static неэффективен при сильном дисбалансе
   - Dynamic и guided обеспечивают лучшую балансировку

2. ✅ **Dynamic показывает лучшую балансировку**
   - Автоматическое распределение работы
   - Потоки не простаивают
   - Накладные расходы компенсируются лучшей утилизацией

3. ✅ **Guided - оптимальный компромисс**
   - Меньше накладных расходов чем dynamic
   - Лучше балансировка чем static
   - Адаптивный размер chunk'а

4. ✅ **Chunk_size значительно влияет на производительность**
   - Малый chunk: лучше для сильно неравномерной нагрузки
   - Большой chunk: меньше overhead, но хуже балансировка
   - Default (0): хороший выбор в большинстве случаев

5. ✅ **Эффективность снижается с ростом потоков**
   - Накладные расходы на синхронизацию растут
   - Дисбаланс нагрузки становится более заметным
   - Оптимальное количество потоков зависит от размера задачи

6. ✅ **Размер задачи влияет на выбор стратегии**
   - Малые задачи: overhead может быть значительным
   - Большие задачи: преимущества dynamic/guided очевидны

## Применение в реальных задачах (Real-world Applications)

### Неравномерные вычисления
- Обработка данных с переменной сложностью
- Адаптивные алгоритмы
- Задачи с условными ветвлениями

### Научные вычисления
- Моделирование с переменным шагом
- Адаптивные сетки
- Итеративные методы с переменной сходимостью

### Обработка данных
- Парсинг файлов разного размера
- Обработка изображений разного разрешения
- Анализ данных с переменной сложностью

## Автор (Author)

Задание выполнено в рамках курса "Введение в суперкомпьютерные вычисления"

## Лицензия (License)

Учебный проект