{
  "description": "Test configurations for Task 6: Loop Scheduling Investigation",
  "workload_pattern": {
    "description": "Uneven workload distribution",
    "heavy_iterations": "Every 10th iteration (10000 operations)",
    "medium_iterations": "Every 5th iteration, not 10th (5000 operations)",
    "light_iterations": "All other iterations (minimal work)"
  },
  "test_parameters": {
    "iterations": [1000, 2000, 5000, 10000],
    "threads": [1, 2, 4, 8, 16, 32, 64, 128],
    "schedules": ["sequential", "static", "dynamic", "guided"],
    "chunk_sizes": [0, 1, 5, 10, 50],
    "runs_per_config": 10
  },
  "expected_behavior": {
    "static": {
      "description": "Static scheduling with uneven workload",
      "pros": [
        "Minimal overhead",
        "Predictable distribution"
      ],
      "cons": [
        "Poor load balancing with uneven workload",
        "Some threads finish early, others late",
        "Lower efficiency for triangular/uneven patterns"
      ],
      "best_for": "Uniform workload"
    },
    "dynamic": {
      "description": "Dynamic scheduling with runtime load balancing",
      "pros": [
        "Excellent load balancing",
        "Threads get new work as they finish",
        "Handles uneven workload well"
      ],
      "cons": [
        "Higher overhead due to synchronization",
        "Chunk size affects performance"
      ],
      "best_for": "Uneven workload, unpredictable iteration times"
    },
    "guided": {
      "description": "Guided scheduling with decreasing chunk sizes",
      "pros": [
        "Good load balancing",
        "Lower overhead than dynamic",
        "Adaptive chunk sizing"
      ],
      "cons": [
        "More complex than static",
        "May not be optimal for all patterns"
      ],
      "best_for": "Gradually changing workload"
    }
  },
  "chunk_size_impact": {
    "0": "Default (OpenMP decides)",
    "1": "Finest granularity, highest overhead, best balancing",
    "5": "Small chunks, good balancing, moderate overhead",
    "10": "Medium chunks, balanced trade-off",
    "50": "Large chunks, lower overhead, worse balancing"
  },
  "metrics": {
    "execution_time": "Time in milliseconds",
    "speedup": "T(1) / T(n)",
    "efficiency": "Speedup / n",
    "ideal_speedup": "Linear with number of threads"
  }
}