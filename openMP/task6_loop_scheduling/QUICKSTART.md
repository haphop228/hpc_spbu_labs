# Quick Start Guide - Task 6: Loop Scheduling Investigation

## Быстрый старт (Quick Start)

### 1. Компиляция программы (Compile the program)

```bash
cd task6_loop_scheduling/scripts
chmod +x *.sh
./compile.sh
```

Скрипт автоматически:
- Определит вашу ОС (macOS/Linux)
- Установит необходимые зависимости (libomp для macOS)
- Скомпилирует программу с оптимизациями
- Проверит работу OpenMP

### 2. Быстрый тест (Quick test)

```bash
./test_pipeline.sh
```

Это выполнит:
- Компиляцию
- Проверку корректности
- Быстрый бенчмарк
- Проверку Python зависимостей

### 3. Запуск полных бенчмарков (Run full benchmarks)

```bash
./run_benchmarks.sh
```

Это запустит полный набор тестов:
- Количество итераций: 1000, 2000, 5000, 10000
- Количество потоков: 1, 2, 4, 8, 16, 32, 64, 128
- Стратегии: static, dynamic, guided
- Размеры chunk: 0 (default), 1, 5, 10, 50
- По 10 запусков каждой конфигурации

⏱️ **Время выполнения:** ~30-60 минут в зависимости от системы

### 4. Анализ результатов (Analyze results)

```bash
cd ../analysis
python3 analyze.py ../results/benchmark_YYYYMMDD_HHMMSS.csv
```

Замените `YYYYMMDD_HHMMSS` на имя файла, созданного в шаге 3.

Скрипт выведет:
- Таблицу с временем выполнения
- Ускорение (speedup)
- Эффективность (efficiency)
- Сравнение стратегий планирования
- Влияние chunk_size

### 5. Построение графиков (Generate graphs)

```bash
python3 plot_graphs.py
```

Графики будут сохранены в `../graphs/`:
- `execution_time_iter_*.png` - время выполнения vs потоки
- `speedup_iter_*.png` - ускорение vs потоки (с идеальной линией)
- `efficiency_iter_*.png` - эффективность vs потоки
- `schedule_comparison.png` - сравнение стратегий
- `chunk_size_impact_iter_*.png` - влияние chunk_size
- `summary_table.txt` - сводная таблица

## Быстрый тест вручную (Quick Manual Test)

Для быстрой проверки работы программы:

```bash
cd task6_loop_scheduling

# Последовательное выполнение (baseline)
./bin/loop_scheduling 1000 1 sequential 0 5

# Static scheduling, 4 потока
./bin/loop_scheduling 1000 4 static 0 5

# Dynamic scheduling, 8 потоков, chunk=10
./bin/loop_scheduling 1000 8 dynamic 10 5

# Guided scheduling, 16 потоков
./bin/loop_scheduling 1000 16 guided 0 5
```

## Структура результатов (Results Structure)

```
results/
├── benchmark_YYYYMMDD_HHMMSS.csv          # Сырые данные
└── benchmark_YYYYMMDD_HHMMSS_processed.csv # Обработанные данные

graphs/
├── execution_time_iter_1000.png
├── execution_time_iter_2000.png
├── execution_time_iter_5000.png
├── execution_time_iter_10000.png
├── speedup_iter_1000.png
├── speedup_iter_2000.png
├── speedup_iter_5000.png
├── speedup_iter_10000.png
├── efficiency_iter_1000.png
├── efficiency_iter_2000.png
├── efficiency_iter_5000.png
├── efficiency_iter_10000.png
├── schedule_comparison.png
├── chunk_size_impact_iter_*.png
└── summary_table.txt
```

## Параметры программы (Program Parameters)

```bash
./bin/loop_scheduling <num_iterations> <num_threads> <schedule> <chunk_size> <runs> [output_file]
```

- `num_iterations` - количество итераций цикла
- `num_threads` - количество потоков OpenMP
- `schedule` - стратегия: sequential, static, dynamic, guided
- `chunk_size` - размер chunk (0 = default)
- `runs` - количество запусков для усреднения
- `output_file` - (опционально) файл для сохранения результатов

## Паттерн неравномерной нагрузки (Uneven Workload Pattern)

Программа создает цикл с сильно неравномерной нагрузкой:

```
Итерация 0:   ████████████████████ (10000 операций - очень тяжелая)
Итерация 1:   ▓ (минимальная работа - легкая)
Итерация 2:   ▓ (минимальная работа - легкая)
Итерация 3:   ▓ (минимальная работа - легкая)
Итерация 4:   ▓ (минимальная работа - легкая)
Итерация 5:   ██████████ (5000 операций - средняя)
Итерация 6:   ▓ (минимальная работа - легкая)
Итерация 7:   ▓ (минимальная работа - легкая)
Итерация 8:   ▓ (минимальная работа - легкая)
Итерация 9:   ▓ (минимальная работа - легкая)
Итерация 10:  ████████████████████ (10000 операций - очень тяжелая)
...
```

**Распределение:**
- 10% итераций: очень тяжелая работа (каждая 10-я)
- 10% итераций: средняя работа (каждая 5-я, не 10-я)
- 80% итераций: легкая работа (остальные)

## Стратегии планирования (Scheduling Strategies)

### Static
- Равномерное распределение при запуске
- Минимальные накладные расходы
- **Проблема:** плохая балансировка при неравномерной нагрузке

### Dynamic
- Динамическое распределение во время выполнения
- Автоматическая балансировка
- **Преимущество:** отлично справляется с неравномерной нагрузкой

### Guided
- Размер chunk уменьшается экспоненциально
- Компромисс между static и dynamic
- **Преимущество:** хорошая балансировка с меньшими накладными расходами

## Влияние chunk_size

- **0 (default)**: OpenMP выбирает оптимальный размер
- **1**: Наилучшая балансировка, максимальные накладные расходы
- **5**: Малые chunk'и, хорошая балансировка
- **10**: Средние chunk'и, сбалансированный компромисс
- **50**: Большие chunk'и, меньше накладных расходов, хуже балансировка

## Требования (Requirements)

### Система (System)
- macOS или Linux
- Компилятор с поддержкой OpenMP (gcc или clang+libomp)
- Python 3.6+

### Python библиотеки (Python packages)
```bash
pip3 install pandas matplotlib numpy
```

## Устранение проблем (Troubleshooting)

### Ошибка компиляции на macOS
```bash
# Установите GCC с OpenMP
brew install gcc

# Или libomp для Clang
brew install libomp
```

### Python библиотеки не найдены
```bash
pip3 install --user pandas matplotlib numpy
```

### Программа работает медленно
- Уменьшите количество итераций в `scripts/run_benchmarks.sh`
- Уменьшите количество запусков (RUNS=3 вместо 10)
- Используйте меньше потоков

## Что дальше? (Next Steps)

1. Изучите сгенерированные графики в `graphs/`
2. Проанализируйте `summary_table.txt`
3. Обратите внимание на:
   - Как разные стратегии справляются с неравномерной нагрузкой
   - Влияние chunk_size на балансировку
   - Эффективность при разном количестве потоков
   - Накладные расходы на синхронизацию

## Для отчета (For Report)

Используйте следующие графики:
1. **Speedup graphs** - показывают эффективность разных стратегий
2. **Efficiency graphs** - показывают качество масштабирования
3. **Schedule comparison** - сравнение static/dynamic/guided
4. **Chunk size impact** - влияние размера chunk
5. **Summary table** - числовые данные для таблиц в отчете

Ключевые выводы для отчета:
- Какая стратегия лучше для неравномерной нагрузки?
- Как chunk_size влияет на производительность?
- Достигается ли линейное ускорение?
- Какие накладные расходы на разные стратегии?
- Как балансировка нагрузки влияет на эффективность?

## Примеры результатов (Example Results)

### Ожидаемое поведение:

**Static scheduling:**
- Плохая балансировка нагрузки
- Некоторые потоки получают много тяжелых итераций
- Низкая эффективность при большом количестве потоков

**Dynamic scheduling:**
- Отличная балансировка нагрузки
- Потоки автоматически получают новую работу
- Лучшая производительность для данной задачи
- Накладные расходы компенсируются лучшей утилизацией

**Guided scheduling:**
- Хорошая балансировка
- Меньше накладных расходов чем dynamic
- Оптимальный компромисс для многих случаев

**Влияние chunk_size:**
- Малый chunk (1-5): лучшая балансировка, больше overhead
- Средний chunk (10): хороший баланс
- Большой chunk (50): меньше overhead, хуже балансировка

## Проверка корректности (Correctness Verification)

Программа автоматически проверяет точность вычислений:

```
=== Correctness Verification ===
Sequential result: 123456.789012
Static result:     123456.789012 (error: 0.000000e+00)
  ✓ PASSED
Dynamic result:    123456.789012 (error: 0.000000e+00)
  ✓ PASSED
Guided result:     123456.789012 (error: 0.000000e+00)
  ✓ PASSED
```

✅ Все стратегии дают корректные и согласованные результаты!

## Дополнительная информация (Additional Information)

Полная документация: см. [README.md](README.md)

## Особенности Task 6 (Task 6 Features)

**Ключевые аспекты:**
1. ✅ Цикл с неравномерной нагрузкой (генерация случайных чисел)
2. ✅ Три стратегии планирования (static, dynamic, guided)
3. ✅ Исследование влияния chunk_size
4. ✅ Анализ балансировки нагрузки
5. ✅ Демонстрация важности выбора правильной стратегии

**Ключевые инсайты:**
- Правильный выбор стратегии критичен для производительности
- Неравномерная нагрузка требует dynamic или guided
- Chunk_size значительно влияет на балансировку
- Балансировка нагрузки важнее минимизации overhead