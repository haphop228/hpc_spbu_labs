# Quick Start Guide - Task 9: Nested Parallelism

## Быстрый старт за 3 шага

### Шаг 1: Компиляция
```bash
cd task9_nested_parallelism/scripts
chmod +x *.sh
./compile.sh
```

### Шаг 2: Быстрый тест
```bash
./test_pipeline.sh
```

### Шаг 3: Полный бенчмарк
```bash
./run_benchmarks.sh
```

## Анализ результатов

```bash
cd ../analysis
python3 analyze.py ../results/benchmark_*.csv
python3 plot_graphs.py
```

Графики будут в директории `graphs/`

## Примеры запуска

```bash
# Последовательное выполнение (baseline)
./bin/nested_parallelism 1000 1 sequential 10

# Плоский параллелизм, 4 потока
./bin/nested_parallelism 1000 4 flat 10

# Вложенный параллелизм, 2×2=4 потока
./bin/nested_parallelism 1000 2:2 nested 10

# Вложенный параллелизм, 4×2=8 потоков
./bin/nested_parallelism 1000 4:2 nested 10

# Проверка поддержки вложенного параллелизма
./bin/nested_parallelism 100 2 flat 1 | grep -A 20 "Checking Nested"
```

## Что тестируется

- **Методы**: sequential, flat (single-level), nested (two-level)
- **Размеры матриц**: 500×500, 1000×1000, 2000×2000
- **Потоки**: 1, 2, 4, 8, 16, 32, 64, 128
- **Конфигурации nested**: 
  - 2×1=2, 2×2=4, 4×2=8, 4×4=16, 8×4=32, 8×8=64, 16×8=128

## Ожидаемые результаты

### Плоский параллелизм (Flat)
- **Малые матрицы (500×500)**: 2-4x ускорение
- **Средние матрицы (1000×1000)**: 4-8x ускорение
- **Большие матрицы (2000×2000)**: 8-16x ускорение

### Вложенный параллелизм (Nested)
- **Обычно сопоставим с flat** или немного медленнее
- **Дополнительные накладные расходы** на создание вложенных регионов
- **Может быть эффективен** для очень больших матриц и специфических конфигураций

## Время выполнения

- Быстрый тест: ~1 минута
- Полный бенчмарк: ~20-40 минут

## Требования

- GCC с OpenMP или Clang с libomp
- Поддержка nested parallelism (проверяется автоматически)
- Python 3 с pandas, matplotlib, numpy
- Минимум 4 ядра CPU (рекомендуется 8+)

## Особенности Task 9

**Ключевые аспекты:**
1. ✅ Проверка поддержки вложенного параллелизма компилятором
2. ✅ Реализация плоского параллелизма (baseline)
3. ✅ Реализация вложенного параллелизма (two-level)
4. ✅ Сравнение производительности обоих подходов
5. ✅ Анализ накладных расходов

**Ключевые инсайты:**
- Flat parallelism обычно эффективнее для большинства задач
- Nested parallelism имеет дополнительные накладные расходы
- Выбор подхода зависит от размера задачи и архитектуры
- Важно измерять производительность обоих методов

## Формат конфигурации nested

Для вложенного параллелизма используется формат `outer:inner`:
- `2:2` = 2 внешних × 2 внутренних = 4 потока
- `4:2` = 4 внешних × 2 внутренних = 8 потоков
- `8:4` = 8 внешних × 4 внутренних = 32 потока

Внешние потоки распределяют строки матрицы, внутренние - элементы в строке.

## Проверка поддержки

Программа автоматически проверяет:
```
=== Checking Nested Parallelism Support ===
Max active levels: 2
Nested parallelism enabled: YES

Testing nested parallelism:
  Outer thread 0/2 -> Inner thread 0/2
  Outer thread 0/2 -> Inner thread 1/2
  Outer thread 1/2 -> Inner thread 0/2
  Outer thread 1/2 -> Inner thread 1/2

✓ Nested parallelism is SUPPORTED
```

## Устранение проблем (Troubleshooting)

### Nested parallelism не поддерживается
```bash
# Убедитесь, что используете GCC или Clang с libomp
gcc --version
# или
clang --version

# Для macOS установите GCC:
brew install gcc

# Или libomp для Clang:
brew install libomp
```

### Python библиотеки не найдены
```bash
pip3 install --user pandas matplotlib numpy
```

### Программа работает медленно
- Уменьшите размеры матриц в `scripts/run_benchmarks.sh`
- Уменьшите количество запусков (RUNS=3 вместо 10)
- Используйте меньше потоков

## Что дальше? (Next Steps)

1. Изучите сгенерированные графики в `graphs/`
2. Проанализируйте `summary_table.txt`
3. Обратите внимание на:
   - Сравнение flat vs nested
   - Накладные расходы вложенного параллелизма
   - Влияние конфигурации outer:inner
   - Масштабируемость обоих подходов
   - Оптимальные конфигурации для разных размеров

## Для отчета (For Report)

Используйте следующие графики:
1. **Speedup comparison** - сравнение ускорения flat vs nested
2. **Efficiency graphs** - анализ эффективности
3. **Direct comparison** - прямое сравнение времени выполнения
4. **Summary table** - числовые данные для таблиц
5. **Nested support check** - демонстрация поддержки компилятором

Ключевые выводы для отчета:
- Компилятор поддерживает вложенный параллелизм
- Flat parallelism обычно эффективнее
- Nested parallelism имеет дополнительные накладные расходы
- Выбор подхода зависит от задачи и архитектуры
- Важность измерения производительности обоих методов