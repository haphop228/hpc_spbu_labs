# Task 7: Reduction Operations with Different Synchronization Methods

## Описание задачи (Task Description)

Реализация операции редукции с использованием разных способов организации взаимоисключения (атомарные операции, критические секции, синхронизацию при помощи замков). Оценка эффективности разных подходов. Сравнение полученных результатов с быстродействием операции редукции, выполняемой посредством параметра reduction директивы for.

**Implementation of reduction operations using different synchronization methods in OpenMP:**
- Atomic operations (`#pragma omp atomic`)
- Critical sections (`#pragma omp critical`)
- Manual locks (`omp_lock_t`)
- Built-in reduction clause (baseline for comparison)

The task computes the sum of all elements in a large array and compares the performance and overhead of different synchronization approaches.

## Структура проекта (Project Structure)

```
task7_reduction_sync/
├── src/                          # Source code
│   └── reduction_sync.cpp        # Main program with different sync methods
├── scripts/                      # Automation scripts
│   ├── compile.sh                # Compilation script
│   ├── run_benchmarks.sh         # Benchmark runner
│   └── test_pipeline.sh          # Full test pipeline
├── data/                         # Configuration files
│   └── test_configs.json         # Test parameters
├── analysis/                     # Analysis scripts
│   ├── analyze.py                # Results processing
│   └── plot_graphs.py            # Graph generation
├── bin/                          # Compiled binaries
├── results/                      # Benchmark results (CSV)
├── graphs/                       # Generated graphs
├── .gitignore                    # Git ignore file
└── README.md                     # This file
```

## Быстрый старт (Quick Start)

### 1. Компиляция (Compilation)

```bash
cd task7_reduction_sync/scripts
chmod +x *.sh
./compile.sh
```

Скрипт автоматически:
- Определит вашу ОС (macOS/Linux)
- Найдет подходящий компилятор с поддержкой OpenMP
- Скомпилирует программу с оптимизациями
- Проверит работу OpenMP

### 2. Быстрый тест (Quick Test)

```bash
./test_pipeline.sh
```

Выполнит:
- Компиляцию программы
- Проверку корректности вычислений
- Быстрый бенчмарк
- Проверку зависимостей Python

### 3. Полный бенчмарк (Full Benchmark)

```bash
./run_benchmarks.sh
```

Запустит полный набор тестов:
- Размеры массивов: 1,000,000, 10,000,000, 100,000,000 элементов
- Количество потоков: 1, 2, 4, 8, 16, 32, 64, 128
- Методы синхронизации: builtin, atomic, critical, lock
- По 10 запусков каждой конфигурации

⏱️ **Время выполнения:** ~20-40 минут в зависимости от системы

### 4. Анализ результатов (Analysis)

```bash
cd ../analysis

# Обработка данных
python3 analyze.py ../results/benchmark_YYYYMMDD_HHMMSS.csv

# Генерация графиков
python3 plot_graphs.py
```

## Использование программы (Program Usage)

### Формат команды

```bash
./bin/reduction_sync <array_size> <num_threads> <method> <runs> [output_file]
```

### Параметры

- `array_size` - размер массива (1000000, 10000000, 100000000)
- `num_threads` - количество потоков OpenMP (1, 2, 4, 8, 16, 32, 64, 128)
- `method` - метод синхронизации:
  - `sequential` - последовательное выполнение (baseline)
  - `builtin` - встроенная редукция OpenMP (рекомендуется)
  - `atomic` - атомарные операции
  - `critical` - критические секции
  - `lock` - ручные замки
- `runs` - количество запусков для усреднения
- `output_file` - (опционально) файл для сохранения результатов

### Примеры

```bash
# Последовательное выполнение (baseline)
./bin/reduction_sync 10000000 1 sequential 10

# Встроенная редукция, 4 потока
./bin/reduction_sync 10000000 4 builtin 10

# Атомарные операции, 8 потоков
./bin/reduction_sync 10000000 8 atomic 10

# Критические секции, 16 потоков
./bin/reduction_sync 10000000 16 critical 5

# Замки, 32 потока, с сохранением в файл
./bin/reduction_sync 10000000 32 lock 10 results/test.csv
```

## Реализация (Implementation)

### Задача редукции (Reduction Problem)

Вычисление суммы всех элементов массива:
```
sum = Σ arr[i] для i = 0..N-1
```

Это классическая задача редукции, где множество значений сводится к одному результату.

### Методы синхронизации (Synchronization Methods)

#### 1. Sequential (Baseline)

```cpp
double sum = 0.0;
for (size_t i = 0; i < arr.size(); ++i) {
    sum += arr[i];
}
```

**Характеристики:**
- Последовательное выполнение
- Нет параллелизма
- Используется как baseline для сравнения

#### 2. Built-in Reduction (Recommended)

```cpp
double sum = 0.0;
#pragma omp parallel for reduction(+:sum)
for (size_t i = 0; i < arr.size(); ++i) {
    sum += arr[i];
}
```

**Характеристики:**
- Оптимизированная реализация OpenMP
- Минимальные накладные расходы
- Каждый поток имеет локальную копию переменной
- Автоматическое объединение результатов в конце
- **Наиболее эффективный метод**

**Преимущества:**
- Высокая производительность
- Простота использования
- Оптимизирована компилятором
- Минимальная синхронизация

#### 3. Atomic Operations

```cpp
double sum = 0.0;
#pragma omp parallel for
for (size_t i = 0; i < arr.size(); ++i) {
    #pragma omp atomic
    sum += arr[i];
}
```

**Характеристики:**
- Атомарное обновление общей переменной
- Гарантия атомарности операции
- Синхронизация на каждой итерации
- Высокие накладные расходы

**Преимущества:**
- Простота реализации
- Гарантия корректности
- Подходит для простых операций

**Недостатки:**
- Значительные накладные расходы
- Синхронизация на каждой итерации
- Может быть узким местом при большом количестве потоков

#### 4. Critical Sections

```cpp
double sum = 0.0;
#pragma omp parallel for
for (size_t i = 0; i < arr.size(); ++i) {
    #pragma omp critical
    {
        sum += arr[i];
    }
}
```

**Характеристики:**
- Только один поток может выполнять критическую секцию
- Взаимное исключение на уровне блока кода
- Синхронизация на каждой итерации
- Очень высокие накладные расходы

**Преимущества:**
- Простота использования
- Гарантия взаимного исключения
- Подходит для сложных операций

**Недостатки:**
- Самые высокие накладные расходы
- Сериализация выполнения
- Плохая масштабируемость

#### 5. Manual Locks

```cpp
double sum = 0.0;
omp_lock_t lock;
omp_init_lock(&lock);

#pragma omp parallel for
for (size_t i = 0; i < arr.size(); ++i) {
    omp_set_lock(&lock);
    sum += arr[i];
    omp_unset_lock(&lock);
}

omp_destroy_lock(&lock);
```

**Характеристики:**
- Явное управление блокировками
- Ручная синхронизация
- Гибкость в управлении
- Высокие накладные расходы

**Преимущества:**
- Полный контроль над синхронизацией
- Гибкость в реализации
- Подходит для сложных сценариев

**Недостатки:**
- Требует явного управления
- Риск deadlock при неправильном использовании
- Высокие накладные расходы

## Проверка корректности (Correctness Verification)

Программа автоматически проверяет корректность:

```
=== Correctness Verification ===
Sequential result: 500000000.123456
Built-in result:   500000000.123456 (error: 0.000000e+00)
  ✓ PASSED
Atomic result:     500000000.123456 (error: 0.000000e+00)
  ✓ PASSED
Critical result:   500000000.123456 (error: 0.000000e+00)
  ✓ PASSED
Lock result:       500000000.123456 (error: 0.000000e+00)
  ✓ PASSED
```

✅ Все методы дают корректные и согласованные результаты!

## Метрики производительности (Performance Metrics)

### 1. Время выполнения (Execution Time)
Абсолютное время выполнения операции в миллисекундах.

### 2. Ускорение (Speedup)
```
Speedup = T(sequential) / T(parallel)
```
где T(sequential) - время последовательного выполнения, T(parallel) - время параллельного.

### 3. Эффективность (Efficiency)
```
Efficiency = Speedup / n
```
где n - количество потоков.

Идеальная эффективность = 1.0 (100%)

### 4. Накладные расходы (Overhead)
```
Overhead = T(method) / T(builtin)
```
Относительные накладные расходы по сравнению с встроенной редукцией.

## Генерируемые графики (Generated Graphs)

После запуска анализа в директории `graphs/` создаются:

1. **execution_time_size_*.png** - Время выполнения vs потоки для каждого размера массива
2. **speedup_size_*.png** - Ускорение vs потоки (с идеальной линией)
3. **efficiency_size_*.png** - Эффективность vs потоки
4. **method_comparison.png** - Сравнение всех методов для разных размеров
5. **overhead_analysis.png** - Анализ накладных расходов относительно builtin
6. **summary_table.txt** - Сводная таблица результатов

## Требования (Requirements)

### Система (System)
- macOS или Linux
- Компилятор с поддержкой OpenMP:
  - GCC 11+ (рекомендуется для macOS)
  - Clang с libomp
  - GCC на Linux
- Минимум 4 ядра CPU (рекомендуется 8+)

### Python (для анализа)
```bash
pip3 install pandas matplotlib numpy
```

## Установка зависимостей (Dependencies Installation)

### macOS

```bash
# Установка GCC с OpenMP (рекомендуется)
brew install gcc

# Или установка libomp для Clang
brew install libomp

# Python пакеты
pip3 install pandas matplotlib numpy
```

### Linux

```bash
# GCC обычно уже установлен
sudo apt-get update
sudo apt-get install g++

# Python пакеты
pip3 install pandas matplotlib numpy
```

## Ожидаемые результаты (Expected Results)

### Built-in Reduction
- **Лучшая производительность** во всех сценариях
- Минимальные накладные расходы
- Отличная масштабируемость
- **Рекомендуется для использования**

### Atomic Operations
- Умеренные накладные расходы
- Приемлемая производительность для малого числа потоков
- Деградация при увеличении потоков
- **2-5x медленнее** чем builtin

### Critical Sections
- Высокие накладные расходы
- Плохая масштабируемость
- Сериализация выполнения
- **5-20x медленнее** чем builtin

### Manual Locks
- Высокие накладные расходы
- Похожа на critical sections
- Дополнительные накладные расходы на управление
- **5-20x медленнее** чем builtin

### Влияние размера задачи

**Малые массивы (1M элементов):**
- Накладные расходы на синхронизацию более заметны
- Разница между методами максимальна

**Средние массивы (10M элементов):**
- Баланс между вычислениями и синхронизацией
- Четкая разница между методами

**Большие массивы (100M элементов):**
- Вычисления доминируют
- Разница между методами сохраняется

## Для отчета (For Report)

Используйте следующие материалы:

1. **Графики ускорения** - показывают эффективность разных методов
2. **Графики эффективности** - демонстрируют качество масштабирования
3. **Анализ накладных расходов** - сравнение с оптимальной реализацией
4. **Сравнение методов** - влияние синхронизации на производительность
5. **Таблица summary_table.txt** - числовые данные для отчета

## Ключевые выводы (Key Findings)

1. ✅ **Built-in reduction - наиболее эффективный метод**
   - Минимальные накладные расходы
   - Оптимизирована компилятором
   - Отличная масштабируемость

2. ✅ **Atomic operations - компромиссное решение**
   - Простота использования
   - Умеренные накладные расходы
   - Приемлемо для малого числа потоков

3. ✅ **Critical sections и locks - высокие накладные расходы**
   - Значительная деградация производительности
   - Плохая масштабируемость
   - Не рекомендуется для редукции

4. ✅ **Накладные расходы растут с числом потоков**
   - Больше потоков = больше конкуренция за синхронизацию
   - Atomic/critical/lock показывают деградацию
   - Built-in сохраняет эффективность

5. ✅ **Размер задачи влияет на относительную производительность**
   - Малые задачи: накладные расходы доминируют
   - Большие задачи: разница сохраняется, но менее критична

6. ✅ **Правильный выбор метода синхронизации критичен**
   - Для редукции всегда используйте built-in reduction
   - Atomic/critical/lock только для специальных случаев
   - Понимание накладных расходов важно для оптимизации

## Применение в реальных задачах (Real-world Applications)

### Научные вычисления
- Суммирование больших массивов данных
- Вычисление статистических метрик
- Численное интегрирование

### Обработка данных
- Агрегация результатов
- Подсчет метрик
- Анализ больших датасетов

### Машинное обучение
- Вычисление функций потерь
- Градиентный спуск
- Агрегация результатов по батчам

### Выбор метода синхронизации
- **Редукция**: всегда используйте `reduction` clause
- **Сложные операции**: рассмотрите atomic для простых случаев
- **Критические секции**: только для сложной логики
- **Замки**: когда нужен полный контроль

## Автор (Author)

Задание выполнено в рамках курса "Введение в суперкомпьютерные вычисления"

## Лицензия (License)

Учебный проект