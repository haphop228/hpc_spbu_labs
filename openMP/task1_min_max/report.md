# Отчет по исследованию производительности поиска минимума/максимума в векторе с OpenMP

## 1. Введение

В рамках данного исследования была проведена оценка производительности двух подходов к параллельной реализации поиска минимального и максимального значений в векторе с использованием OpenMP:
1. С использованием встроенных конструкций редукции OpenMP
2. С ручной реализацией без использования редукции

Целью работы является анализ зависимости времени выполнения и ускорения от количества используемых параллельных потоков и масштаба задачи (размеров массивов).

## 2. Описание реализации

### 2.1. Подход с использованием редукции

В этом подходе используются встроенные конструкции редукции OpenMP:

```c
#pragma omp parallel for reduction(min:min_val)
for (long long i = 0; i < n; i++) {
    if (arr[i] < min_val) {
        min_val = arr[i];
    }
}
```

Компилятор автоматически обрабатывает объединение значений от разных потоков, что упрощает реализацию и потенциально позволяет применять оптимизации на уровне компилятора.

### 2.2. Подход без использования редукции

В ручной реализации каждый поток находит локальный минимум/максимум, а затем происходит объединение результатов:

```c
#pragma omp parallel
{
    int tid = omp_get_thread_num();
    double local_min = DBL_MAX;
    
    #pragma omp for
    for (long long i = 0; i < n; i++) {
        if (arr[i] < local_min) {
            local_min = arr[i];
        }
    }
    
    thread_mins[tid] = local_min;
}
// Затем объединение результатов потоков
```

Этот подход дает больше контроля над процессом, но требует явного управления синхронизацией.

## 3. Методология тестирования

### 3.1. Параметры тестирования

- **Размеры векторов**: 1,000,000 (10^6), 10,000,000 (10^7), 100,000,000 (10^8) элементов
- **Количество потоков**: 1, 2, 4, 8, 16, 32, 64, 128 потоков
- **Методы**: "reduction" и "no-reduction"
- **Количество запусков**: 10 запусков для каждой конфигурации для статистической достоверности
- **Операции**: Поиск минимума (MIN) и максимума (MAX)

### 3.2. Метрики оценки производительности

Для анализа производительности использовались следующие метрики:

1. **Время выполнения**: Абсолютное время выполнения операции в миллисекундах
2. **Ускорение (Speedup)**: Отношение времени выполнения на одном потоке к времени выполнения на N потоках:
   $$Speedup = \frac{T_1}{T_N}$$
   где $T_1$ - время выполнения на одном потоке, $T_N$ - время выполнения на N потоках

3. **Эффективность (Efficiency)**: Ускорение, нормализованное по количеству потоков:
   $$Efficiency = \frac{Speedup}{N}$$
   где N - количество потоков

## 4. Результаты исследования производительности

### 4.1. Зависимость времени выполнения от количества потоков

На графиках `execution_time_size_*.png` показано, как время выполнения зависит от количества потоков для разных размеров задач. Вставить графики:
- `graphs/execution_time_size_1000000.png` - для размера 10^6 элементов
- `graphs/execution_time_size_10000000.png` - для размера 10^7 элементов
- `graphs/execution_time_size_100000000.png` - для размера 10^8 элементов

Из графиков видно, что:
- Для малых размеров задач (10^6) время выполнения начинает расти при использовании большого количества потоков (32 и более)
- Для больших размеров задач (10^8) наблюдается более стабильное поведение, с меньшим ростом времени при увеличении количества потоков
- Метод без редукции в целом показывает большее время выполнения по сравнению с методом с редукцией

### 4.2. Зависимость ускорения от количества потоков

На графиках `speedup_size_*.png` показана зависимость ускорения от количества потоков. Вставить графики:
- `graphs/speedup_size_1000000.png` - для размера 10^6 элементов
- `graphs/speedup_size_10000000.png` - для размера 10^7 элементов
- `graphs/speedup_size_100000000.png` - для размера 10^8 элементов

Ключевые наблюдения:
- Для размера 10^6 элементов:
  - Метод с редукцией достигает максимального ускорения ~4.58x при 4 потоках
  - Метод без редукции достигает максимального ускорения ~5.11x при 8 потоках
- Для размера 10^7 элементов:
  - Метод с редукцией достигает максимального ускорения ~4.90x при 8 потоках
  - Метод без редукции достигает максимального ускорения ~7.01x при 16 потоках
- Для размера 10^8 элементов:
  - Метод с редукцией достигает максимального ускорения ~5.39x при 32 потоках
  - Метод без редукции достигает максимального ускорения ~7.81x при 128 потоках

### 4.3. Зависимость эффективности от количества потоков

На графиках `efficiency_size_*.png` показана эффективность параллелизации. Вставить графики:
- `graphs/efficiency_size_1000000.png` - для размера 10^6 элементов
- `graphs/efficiency_size_10000000.png` - для размера 10^7 элементов
- `graphs/efficiency_size_100000000.png` - для размера 10^8 элементов

Из графиков видно, что эффективность снижается с увеличением количества потоков, особенно для малых размеров задач. Это связано с накладными расходами на создание и управление потоками.

### 4.4. Сравнение методов

На графике `graphs/comparison_reduction_methods.png` показано сравнение ускорения для обоих методов на всех размерах данных. Этот график демонстрирует, что:
- Для малых размеров задач метод без редукции может показывать лучшее ускорение
- Для больших размеров задач разница между методами уменьшается
- Оба метода показывают схожую тенденцию масштабируемости

### 4.5. Тепловая карта производительности

График `graphs/performance_heatmap.png` представляет тепловую карту ускорения для всех комбинаций размеров задач и количества потоков. Зеленые области соответствуют высокому ускорению, красные - низкому. Этот график позволяет быстро определить оптимальные конфигурации.

### 4.6. Анализ накладных расходов

График `graphs/overhead_analysis.png` показывает процент времени, потерянного на накладные расходы параллелизации. Положительные значения указывают на потери, отрицательные - на выигрыш. Из графика видно, что накладные расходы растут с увеличением количества потоков.

### 4.7. Сравнение с законом Амдала

График `graphs/amdahls_law_analysis.png` сравнивает реальное ускорение с теоретическими пределами по закону Амдала. Закон Амдала определяет теоретическое ограничение ускорения:

$$Speedup = \frac{1}{(1 - P) + \frac{P}{N}}$$

где P - доля параллельного кода, N - количество потоков.

Из графика видно, что реальные результаты находятся между линиями для 80% и 95% параллельного кода, что указывает на высокую степень параллелизации алгоритма.

## 5. Числовые результаты

В таблице `graphs/summary_table.txt` представлены числовые данные для всех конфигураций. Основные наблюдения:

### 5.1. Для размера 1,000,000 элементов:
- Метод с редукцией: максимальное ускорение 4.58x при 4 потоках
- Метод без редукции: максимальное ускорение 5.11x при 8 потоках

### 5.2. Для размера 10,000,000 элементов:
- Метод с редукцией: максимальное ускорение 4.90x при 8 потоках
- Метод без редукции: максимальное ускорение 7.01x при 16 потоках

### 5.3. Для размера 100,000,000 элементов:
- Метод с редукцией: максимальное ускорение 5.39x при 32 потоках
- Метод без редукции: максимальное ускорение 7.81x при 128 потоках

## 6. Итоговый анализ результатов

### 6.1. Масштабируемость

Оба метода показывают хорошую масштабируемость до определенного количества потоков, после чего начинается деградация производительности. Это связано с накладными расходами на создание и управление потоками, которые начинают перевешивать выигрыш от параллелизации.

### 6.2. Влияние размера задачи

Размер задачи существенно влияет на эффективность параллелизации:
- Для малых размеров задач (10^6) накладные расходы становятся значительными при использовании большого количества потоков
- Для больших размеров задач (10^8) накладные расходы относительно меньше, что позволяет эффективно использовать большее количество потоков

### 6.3. Сравнение методов

- Метод с редукцией в целом показывает лучшее время выполнения благодаря оптимизациям компилятора
- Метод без редукции может показывать лучшее ускорение для определенных конфигураций, особенно при больших размерах задач
- Разница между методами уменьшается с увеличением размера задачи

### 6.4. Оптимальные конфигурации

На основе анализа можно выделить следующие рекомендации:
- Для задач размером 10^6 элементов оптимальное количество потоков: 4-8
- Для задач размером 10^7 элементов оптимальное количество потоков: 8-16
- Для задач размером 10^8 элементов оптимальное количество потоков: 16-64

### 6.5. Накладные расходы

Анализ накладных расходов показывает, что они становятся критичными при использовании большого количества потоков (32 и более). Это необходимо учитывать при выборе количества потоков для конкретной задачи.

## 7. Выводы

1. Оба подхода к параллельной реализации поиска минимума/максимума показывают хорошую масштабируемость до определенного количества потоков.

2. Размер задачи существенно влияет на эффективность параллелизации. Для больших задач можно эффективно использовать большее количество потоков.

3. Метод с редукцией в целом показывает лучшее время выполнения благодаря оптимизациям компилятора, но метод без редукции может показывать лучшее ускорение для определенных конфигураций.

4. Накладные расходы на создание и управление потоками становятся значительными при использовании большого количества потоков, что приводит к деградации производительности.

5. Для достижения оптимальной производительности необходимо выбирать количество потоков в соответствии с размером задачи и характеристиками вычислительной системы.

6. Реальные результаты хорошо соответствуют теоретическим предсказаниям закона Амдала, что подтверждает высокую степень параллелизации алгоритма.